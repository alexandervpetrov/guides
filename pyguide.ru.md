
# Python Development Guide

*Здесь описаны и документированы рекомендации и соглашения по программированию на Python.
За исключением отдельных примеров тут нет слишком специфичной информации - это общие
рекомендации и философия разработки. Есть надежда что документирование таких вещей
поможет команде быть более сбалансированной и поможет эффективнее поддерживать в коде
ряд ценностей важных для эволюции проекта.*


Самыми базовыми вещами в плане стиля и вкуса для любого программиста на Python
являются [The Zen of Python (PEP 20)][pep20] и [Style Guide for Python Code (PEP 8)][pep8] -
они обязательны к прочтению. Абсолютно весь Python-код на проекте **должен** проходить
проверку на соответствие PEP 8 стандартной утилитой [pycodestyle][pycodestyle]
в режиме проверки всех ошибок за исключением ограничения на длину строки (`--ignore=E501`).

Основой для соглашений по стилю кодирования является [Google Python Style Guide][googlepyguide],
его необходимо прочитать, если в данной статье прямо что-то не оговорено,
то значит по умолчанию берётся соглашение из этого руководства Гугла.

Также грамотные и разумные вещи можно почитать в [The Hitchhiker’s Guide to Python][hitchhiker].

[pep20]: https://www.python.org/dev/peps/pep-0020/
[pep8]: https://www.python.org/dev/peps/pep-0008/
[pycodestyle]: https://pypi.org/project/pycodestyle/
[googlepyguide]: https://github.com/google/styleguide/blob/gh-pages/pyguide.md
[hitchhiker]: https://docs.python-guide.org/


## 1. Ясность и простота

Главным приоритетом при написании кода всегда должно быть сочетание красоты, ясности,
читабельности и простоты. Код пишется **в первую очередь для людей** которые его будут
читать и поддерживать, и лишь во вторую очередь для выполнения задачи.
**Недопустимо** коммитить неясный или трудно поддерживаемый код, аргументируя "он же работает"
или "мне понятно". Если код плохо понимает коллега при ревью - это серьёзное основание
для того, чтобы уделить дополнительное время и переделать.

**Наименования**. Очень важно выбирать удачные названия для переменных, функций, модулей.
Обращайте внимание на форму слова, например для обработчиков событий разумно использовать
[past participle][participle] (`clicked`, `saved`, `moved`, ...), для действий - инфинитив
(`click`, `save`, `move`, ...),
для функций возвращающих булевские значений часто удобен префикс `is_`.
Какую бы схему наименований вы не выбрали будьте последовательны! Недопустимо в рамках
одного модуля перемешивать разные стили или схемы наименований. Если удачное слово
не приходит в голову, то удобно пробовать [подбирать синонимы][thesaurus]. Названия переменных
должны соответствовать величине области использования и видимости. К примеру, если переменная
используется только в scope цикла длиной несколько строк, то вполне допустимо назвать
её в одну или несколько букв, но чем шире область использования - тем более содержательнее
и осмысленнее должно быть название.

*Придумывание кода* - это большей частью управление сложностью и управление зависимостями.
Автор кода всегда должен стремится минимизировать сложность кода и сделать минимальными
зависимости частей системы от друг друга, либо по крайней мере сделать зависимости явными и хорошо
структурированными. Очень часто эти цели конкурируют с друг другом - бывает, что уменьшить
сложность кода можно только ценой введения дополнительной зависомости (вызов вспомогательной
функции или использование модуля/библиотеки), и наоборот - иногда убрать зависимость можно
только ценой повышения сложности кода (написав свою реализацию чего-то, вводя дополнительные
слои - например добавляя обработчики ошибок). Большей частью искусство написания хорошего кода,
опыт программиста и состоят в подборе удачного баланса между этими двумя вещами.

**Сложность**. Функции полезно оценивать как просто по длине кода - количеству значащих строк,
так и прикидывать [цикломатическую сложность][cyclomatic] - её можно понимать либо как разность между
количеством ветвлений (`if`-ов) и количеством точек выхода (`return`-ов), либо как количество
тестов необходимое для полного покрытия кода. Нужно стремиться разбивать свой код
на функции *лаконичные* - до 40-60 строк, и *простые* - цикломатическая сложность не более 10-15.

**Зависимости**. Python довольно выразительный язык с богатыми возможностями стандартной библиотеки.
Если можно что-то лаконично и ясно реализовать без использования вспомогательных функций
из других модулей, то нужно стараться так и делать. Дублирование коротеньких кусочков кода -
это не всегда зло! Далеко не всегда нужно выделять повторяющийся кусок в отдельную
библиотечную функцию - нужно думать о том, что это создаёт зависимость. Выделять
в функции-утилиты разумно только те кусочки работы, которые потенциально нужно будет
переопределить, изменить поведение. Граф/карта зависомостей должна иметь слоистую/древовидную
структуру небольшой глубины, а не "спагетти". Циклические зависимости следует рассматривать как временные
"костыли" и следствие плохой архитектуры и если уж нельзя их избежать прямо в данный момент,
то всегда ставить рядом поясняющий комментарий под тегом `TODO` или `FIXME` добавляя в технический долг.

[participle]: https://en.wikipedia.org/wiki/Participle#Modern_English
[thesaurus]: https://www.thesaurus.com/
[cyclomatic]: https://en.wikipedia.org/wiki/Cyclomatic_complexity


## 2. Производительность

Выражение Энтони Хоара "Преждевременная оптимизация - корень всех зол в программировании"
часто понимают неправильно. Очень хорошая статья на эту тему [The Fallacy of Premature Optimization][fallacyofopt].
**Необходимо** думать о производительности на стадии дизайна кода, на стадии его придумывания,
до и в процессе его написания. **Необходимо** думать об алгоритмической сложности,
об оценке затрат памяти, о количестве запросов к базе данных и просто о количестве
сетевых запросов. Конечно же, **необходимо** знать оценки времени работы операций
со стандартными структурами данных в Python. В то же время нужно помнить и том,
что ясность и простота прежде всего. К примеру, не нужно делать короткими и нечитабельными
названия параметров запроса или параметров в передаваемых по сети структурах данных,
аргументируя это меньшим объёмом передачи байтов, без соотвествующих замеров и обоснования.
Читабельность данных при отладке и поддержка кода, как правило, важнее нескольких процентов быстродействия.

[fallacyofopt]: https://ubiquity.acm.org/article.cfm?id=1513451


## 3. Структура

При разделении кода на структурные единицы (модули, пакеты, слои, приложения)
недостаточно думать только об интерфейсах в смысле действий импортируемых функций,
нужно внимательно проектировать какими структурами данных и объектами будет происходить
обмен информацией через интерфейс. Следует стремиться выражать всё встроенными/стандартными
объектами и структурами. Если получается вернуть простой словарь, то нужно так и сделать.
Если получается принимать в качестве аргументов типы из стандартной библиотеки -
то нужно так и сделать. Такое выражение потоков информации через стандартные типы
не усложняет и не даёт разрастаться зависимостям в проекте. Также это облегчает отладку.
Любое отступление от этого правила **должно выноситься на обсуждение** в команде.
Перечень нестандартных объектов которыми можно обмениваться между отдельными слоями
абстракции в приложении должен быть небольшим и известен всем.
Выбрасываемые исключения - это часть интерфейса и зависимость! Нужно думать каким исключениям позволять
выходить за границы интерфейса, а каким - нет.

**Пример**. В Джанго-приложениях как правило выделяют слои `view` и `bl` (business logic).
Задача слоя `view` - провалидировать сетевой запрос, выразить его через вызовы
функций из `bl` и преобразовать полученные данные для отправки сетевого ответа.
Слой `view` **не должен** делать ничего кроме этого, в частности, не должен делать
прямых запросов в базу данных минуя `bl`. Функции из `bl` должны принимать в качестве
аргументов лишь простые/стандартные типы данных (недопустимо передавать
ORM-объект `user`, разрешается передавать лишь `user_id`), и должны возвращать либо
простые типы данных, либо объект `query`, который `view` имеет право лишь отсортировать
или выбрать возвращаемые поля, а после чего сериализовать в простой тип
функцией-сериализатором из того же `bl`. Если соблюдать эти правила, то значительно
упрощается тестирование и поиск ошибок в коде, происходит чёткое разделение
зависимостей слоёв. Более того, функции из `bl` становится легко импортировать и
переиспользовать в других пакетах или приложениях - вызываемый код зависит только
лишь от стандартных типов.


## 4. Парадигмы программирования

Хоть Python и не является [функциональным][fp] языком программирования, но использовать
в разработке элементы ФП полезно и разумно. Быть может когда-то все приложения будут писать
на каком-то Clojure с поддержкой со стороны языка, ну а пока нужно делать что в наших возможностях.
Стараться выражать код функциями без побочных эффектов. Результат работы функций
должен зависеть лишь от аргументов. Недопустимо, чтобы поведение функции зависело
от неконстантных объектов переданных не через аргументы. Например, не стоит использовать
глобальную функцию Джанго `get_current_request()` и подобные ей в других фреймворках.
Большинство паттернов проектирования в функциональных языках [можно][clojurepatterns] эффективно и лаконично
выразить без классов, пользуясь лишь функциями и встроенными типами данных.
Старайтесь интенсивно пользоваться тем, что функции в Python - это [объекты первого класса][firstclass],
их можно объявлять в любом scope, присваивать переменным, передавать в качестве аргументов
и возращать в качестве результата.

Почитайте про [программирование по контракту][dbc].
Думайте при написании кода о [предусловиях][precond], [постусловиях][postcond], [инвариантах][invariant]
и других вещах (возможных ошибках, побочных эффектах, гарантиях быстродействия, ...).

Если задачу можно решить без написания классов, то так и нужно делать.
Использовать классы при написании кода теоретически можно по крайней мере двумя способами: 1) просто
для упаковки данных в объекты, в качестве namespace-ов как альтернатива
стандартным словарям или 2) строить иерархии, применять наследование и другие принципы ООП.
Если хочется написать класс для первого варианта, для удобной упаковки данных,
то нужно подумать о том, что это будет создавать зависимость у потребителей,
будет вынуждать импортировать этот класс для создания данных, что может усложнить
тестирование, к примеру.

"Я хочу использовать ООП, что делать?" Используйте его правильно и лишь там где это уместно!
Если вы хотите написать класс от которого не собираетесь наследоваться и не собираетесь
строить иерархию перегружая поведение, то скорее всего вашу задачу можно легко решить
и без классов вовсе, на функциях и стандартных структурах данных. Если вы собираетесь
написать класс где для данных не получается придумать инварианта, то это не ООП,
а просто упаковка данных, и не стоит делать функции обработки данных методами класса,
[инкапсуляция][encapsulation] без инварианта не имеет смысла. Если вы всё же строите наследование,
то делайте это правильно, соблюдая [принцип подстановки Лисков][liskov] - в производных классах
инварианты должны быть сохранены, предусловия не должны усиливаться,
а постусловия не должны ослабляться.

Лично моя позиция - ООП на проекте не должно быть вовсе, кроме случаев когда фреймворк
к этому вынуждает - как, например, в моделях ORM или других вспомогательных объектах
служащих точками настройки.

*TODO: asynchronous I/O, event-driven architectures*

[fp]: https://en.wikipedia.org/wiki/Functional_programming
[clojurepatterns]: http://mishadoff.com/blog/clojure-design-patterns/
[firstclass]: https://en.wikipedia.org/wiki/First-class_function
[dbc]: https://en.wikipedia.org/wiki/Design_by_contract
[precond]: https://en.wikipedia.org/wiki/Precondition
[postcond]: https://en.wikipedia.org/wiki/Postcondition
[invariant]: https://en.wikipedia.org/wiki/Invariant_(computer_science)
[encapsulation]: https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)
[liskov]: https://en.wikipedia.org/wiki/Liskov_substitution_principle


## 5. Обработка ошибок

Ошибка - перегруженное и неоднозначное слово.
Следует различать неисправности (fault), сбои в работе (failure) и просто ошибки (error).

**Неисправность (fault)** - это нечто, что приводит к непреднамеренному или
непредсказуемому поведению программы. Это поведение программы которое не закладывалось
при проектировании и написании. Как правило, это либо неправильная логика работы
или сбой в виде некоего необрабатываемого exception-а. Это "ошибка программиста",
то есть ошибочное проектирование или реализация. Должна быть как можно более видимой
и обнаруживаемой. Цель - выявлять все неисправности на стадии разработки
и тестирования или как можно быстрее обнаруживать и исправлять их в продакшне.
Для этого нужно писать в лог (или в другие сервисы мониторинга и репортов) все
необработанные исключения, постоянно измерять быстродействие работающей системы,
мониторить потребление ресурсов, организовывать процес тестирования.
**Недопустимо** слабоспецифично перехватывать исключения без обработки (например,
`except Exception: pass`) и никуда не сообщать о них, например в лог.

**Сбой в работе (failure)** - это неспособность системы, компонента или функции
выполнить свою работу с учетом требуемого быстродействия, неспособность кода выполнить
свою работу в соответствии с контрактом. Либо работа не выполнена, либо работа
не выполнена достаточно быстро, или с нарушением других ограничений.
Сбои зависят от среды выполнения и обязательно время от времени возникают
в работающей системе. Примеры: файл не найден; нет свободного места на диске; не получается открыть файл на запись;
не получается установить сетевое соединение; сетевое соединение отвалилось;
запрос выполняется слишком долго; транзакция не может завершиться;
внешний сервис недоступен; пользователь отправляет смс, а внешний шлюз отвечает
500-ым статусом. Правильная обработка сбоев является **обязанностью** программиста.
Программист должен пытаться предусмотреть все существенные сбои и написать код
ответственный за реагирование системы на них. Как именно реагировать на сбои -
просто ли написать в лог и не выполнить операцию, попробовать выполнить ещё раз,
аварийно остановить процесс, ... - это решается в каждом случае отдельно,
неочевидные решения стоит обсуждать в команде. Какие сбои не считать существенными и
не обрабатывать - это решается коллегиально, с учётом маркетинговых и технических
последствий, это должно быть осознанное и задокументированное решение.

**Просто ошибка (error)** - несоответствие между реальным результатом выполнения
операции (вычисленным, наблюдаемым, измеренном) и теоретически правильным и желаемым,
то есть работа была выполнена, но что-то в результате не устраивает.
Что считать сбоем, а что простой ошибкой иногда зависит от дизайна и архитектуры кода -
неуспешное открытие файла может быть сбоем делающим невозможной выполнение какой-либо
операции, а может быть ожидаемой ошибкой, с задуманной стратегией восстановления и
продолжения работы. Примеры: параметры запроса из сети не прошли валидацию -
несуществующий идентификатор, неправильный формат или дата в будущем; пользователь
присылает запрос на списание со счёта суммы больше чем там есть; пользователь отправляет смс,
а внешний шлюз отвечает "нет денег на счёту" или "ошибка авторизации".
Просто ошибки - это ожидаемое и обрабатываемое поведение, но неуспешное с точки зрения
вызывающей стороны. Для просто ошибок нужно, как правило, вести их учёт и историю
(например, в БД) и/или детально пробрасывать их на более внешние слои системы,
вплоть до уведомления пользователей.

В разных языках программирования используются разные конструкции для уведомлений
об ошибках и их обработки. В основном конкурируют два крайних подхода: 1) чисто функциональный -
паковать ошибки в возращаемые значения и 2) использовать исключения (exceptions).

Важно выбрать какую-либо стратегию обработки ошибок и придерживаться её.
Обычно для кода на Пайтоне выбирают использовать исключения, но это работает хорошо
лишь для монолитных и замкнутых систем. Если же вы, к примеру, проектируете взаимодействующие
по сети сервисы, то исключениями не обойдёшься и придётся думать об обмене ошибками
между интерфейсами.

Последнее время мне кажется разумным использовать в Python в пределах одной подсистемы разный
подход для разных типов ошибок.
Для просто ошибок использовать возвращаемые значения, а для сбоев в работе - исключения.
Например:

```python
def send_sms(to, text):
    """
    Returns:
        (message_id, None) for success,
        (None, (code, message)) otherwise.
    """
    log.debug('Sending sms: %s - %s', to, text)
    data = dict(to=to, text=text)
    response = requests.post('http://remote-gateway.com/api/send', data=data, timeout=3)
    if response.status != 200:
        raise Error('Failed to send sms with remote status: {}'.format(response.status))
    answer = response.json()
    if not answer['ok']:
        error = (answer['code'], answer['message'])
        return None, error
    return answer['message_id'], None
```

Здесь мы видим: 1) запрос к внешнему сервису может не пройти - это считается сбоем
и исключение пробросится вне функции; 2) запрос может быть прерван по таймауту -
тоже считается сбоем и тоже исключение без изменений пробрасывается наверх;
3) если HTTP-запрос всё же прошёл по сети успешно, то сервер мог его не обработать -
это тоже в рамках задачи этой функции трактуется как сбой и преобразовывается
в специфичное исключение; 4) если HTTP-запрос был успешно обработан сервером,
то считается что сбоя нет, но пожелание вызывающей стороны ("отправить смс")
всё же могло быть не выполнено - смс не отправлено (нет денег, нет авторизации, ...) -
это трактуется и возращается как простая ошибка.

Способ использования этой фукции отправки смс тогда может быть таким:

```python
def process_payment(...):
    ...
    to = phone_number
    text = 'You payment was processed'
    try:
        message_id, error = send_sms(to, text)
    except Error as e:
        # process failure
        log.error('Failed to send sms: %s', e)
    except Exception as e:
        # and/or process failure and re-raise it to upper level
        log.error('Failed to send sms: %s', e)
        raise
    else:
        if error is not None:
            # process error
            log.warn('Sms was not sent: %s', error)
            return
        # process success
        log.info('Sms was sent')
        ...
```

Таким образом, такой стиль работы с ошибками разных видов вынуждает программиста
обрабатывать и проверять простые ошибки сразу при возврате из функции,
но даёт свободу в обработке сбоев - на каком уровне их ловить - это предмет договорённости
и проектирования. Также программист выбирает при реализации функции какие сбои
без изменений пробросить наверх, а какие - преобразовать в более специфичные исключения
или вообще в простые ошибки.

Описанный подход, возвращение из функции пары значений `(результат, ошибка)` с последующей
проверкой - это ручное выражение потока управления подобное [Either][either] в функциональных языках,
и синтаксически сходно с подходами к обработке ошибок в [Go][errors-in-go] и [Rust][errors-in-rust].
В Пайтоне оно конечно выглядит синтаксически не особо красиво, но успешно работает.

[either]: https://funcool.github.io/cats/latest/#either
[errors-in-go]: https://blog.golang.org/error-handling-and-go
[errors-in-rust]: https://doc.rust-lang.org/book/2018-edition/ch09-00-error-handling.html


## 6. Логирование и измерения

Необходимо быть способным отвечать вопросы "Что этот пользователь делал в системе
в такое-то время?" или "Что происходило в системе в такое-то время?" или
"Что происходило в системе незадолго до этого сбоя или в окресности такого-то события?".
В перспективе, в современном мире, анализируют ответы на эти вопросы часто уже даже не люди,
а программы. Сложно переоценить важность хорошего логирования для отладки и отслеживания
работы системы.

В лучшем случае логирование должно быть [структурным][structlog] для гибкости в плане настройки выходного формата
и индексирования для поиска.
Но из соображений совместимости или лени часто на проектах логирование является текстовым через пакет `logging`
из стандартной библиотеки.

Важно логировать каждую успешную операцию пользователя изменяющую информацию.
Также важно логировать все обращения к другим компонентам и сервисам, как своим так и внешним.

- **CRITICAL**
  - Информация от ситуациях приводящих к аварийной остановке системы
    или о потере способности системы выполнять несколько функций сразу (потеря соединения с БД,
    нехватка ресурсов, ...)
  - Вероятные неисправности
- **ERROR**
  - Информация о любых сбоях в работе, о неспособности системы выполнить какую-то отдельную функцию
  - Вероятные неисправности
- **WARNING**
  - Простые ошибки: как результаты действий пользователя которые не привели к желаемому,
    так и любые другие результаты работы сигнализирующие о неуспехе
- **INFO**
  - Информация которую мы хотим видеть для анализа типичных событий в работающей системе:
    - Этапы жизненного цикла системы или компонента: запуск, изменение конфигурации, остановка
    - Успешное выполнение пользователем действий изменяющих состояние или информацию в БД
    - Запросы к внешним сервисам
    - Результаты работы функции, компонента, сервиса
- **DEBUG**
  - Информация которую мы хотим видеть для анализа событий как в работающей системе, так и при разработке, отладке и тестировании:
    - Любые детальные данные для отладки - что сейчас происходит и с какими данными
    - Начало работы функции / операции и входные параметры
    - Начало действия пользователя изменяющее состояние и параметры операции
    - Старт запроса к другому компоненту или (внешнему) сервису
    - Ответ возвращённый другим компонентом или (внешним) сервисом
    - Успех или неуспех работы какой-либо функции
- **TRACE**
  - Результаты измерений - время выполнения функций, количество запросов к базе и т. п.

Перехваченные неожидаемые исключения (вероятные неисправности) всегда логируются с полной
информацией о `stack trace (exc_info=True)`.

`TRACE` - это нестандартный уровень, но в любую систему логирования его поддержку леко добавить.

Логирование является обязательной частью разработки любого функционала. Отсутствие
обдуманного логирования в коде - это серьёзное основание для того, чтобы уделить
дополнительное время и переделать.

При текстовом логировании очень полезно в префиксы сообщений включать контекст события - идентификатор компании
или пользователя в рамках или от имени которых происходит действие в системе.
Чтобы потом можно было удобно фильтровать `grep`-ом. Например строка
`[c:179] [i:605] [p:1005] New session created: 4806499` означает, что сессия телефонного
звонка была создана для компании 179 через интеграцию 605 и для трубки 1005.

В структурном логировании такое включение контекста удобно поддерживается на уровне библиотеки.

Полезно также все сообщения начиная с уровня `ERROR` и выше отправлять ещё и в какой-нибудь
сервис сбора ошибок, типа [Sentry][sentry] или [Rollbar][rollbar].
Там удобно настроить оповещения как для быстрого реагирования,
так и регулярно просматривать и принимать меры.

Для функций и операций удобно устанавливать контракт по быстродействию или ресурсам
(время работы, количество запросов к базе, ...) - чтобы все метрики писались с уровнем `TRACE`,
а если превышают пороговые значения - сигнализировали как сбой в работе с уровнем `ERROR`.

[structlog]: http://www.structlog.org
[sentry]: https://sentry.io
[rollbar]: https://rollbar.com/


## 7. Хранение информации

Не храните информацию безсистемно! Придумайте стратегию и придерживайтесь её.

Место на диске сейчас дешёво. Не удаляйте ничего из базы средствами приложения.
База данных - это хранилище только для добавления и изменения. Видимое удаление
для пользователя легко реализуется через атрибуты `deleted` типа `timestamp`.
Тогда условие `deleted is NULL` будет индикатором того, что запись ещё не удалена.

Для хранения фрагментов информации которая редко меняется и почти всегда
извлекается целиком удобно использовать JSON или подобные типы.

Давайте осмысленные названия файлам миграций.

*TODO: Append-only storage, Event Sourcing, Caching*


## 8. Транзакции

Если вы создаёте функцию или фрагмент кода работающие с базой данных, то важно думать
нужна ли им транзакция, зависит ли успешность работы от согласованности с другими данными,
нужна ли атомарность выполнения операций и тому подобное. Если работоспособность функции
зависит от того выполняется она в транзакции или без, то это должно быть или задокументировано
`docstring`-ом `Requires transaction` или выражено каким-то контрактом.
Управление транзакциями, старт транзакции через context manager,
должно делаться на самом верхнем уровне работы с базой - для веб-фреймворков, например,
в слое `view`, если пишем обработчик запроса. Это не самое гибкое решение, но уж как
есть с учётом особенностей большинства веб-фреймворков. Функции слоя `bl` не должны самостоятельно
управлять транзакциями.

По умолчанию, если транзакция нужна, то создавайте её с уровнем изоляции `SERIALIZABLE`.
Используйте другой уровень, только если действительно знаете что делаете и есть
серьёзная необходимость, например аргументированная измерениями потребность в быстродействии
с учётом возможной жертвы корректности.


## 9. Работа с внешними сервисами

Очень важно думать о возможных сбоях в работе. Недоступность внешнего сервиса не должна
приводить к непреднамеренному падению нашей системы, а должна правильно и предсказуемо
обрабатываться как простая ошибка или сбой в работе. Желательно транслировать исключения
при сбоях в работе во внутренние специфические. Логирование взаимодействия с внешним
сервисом обязательно!


## 10. Прочее

### 10.1 Декораторы


Очень часто на разных проектах злоупотребляют интенсивным использованием декораторов.
Декораторы - это иногда очень удобно, как, например, преобразование возвращаемого объекта в JSON,
а иногда совсем неудобно или неуместно - как например для управления транзакциями.
Если хотите сделать декоратор для чего-либо, сначала напишите реализацию без декоратора,
сделайте ревью и обсуждение с коллегой, и ещё раз хорошо подумайте.

Важно хорошо называть декораторы и различать их по действию которое они производят:
1) что-либо делают *до* вызова декорируемой функции (pre-operation), но ничего не делают после;
2) ничего не делают до вызова, но делают *после* - например преобразовывают возвращенное
значение (post-operation);
3) делают что-либо более сложное - или и до и после,
или меняют каким-то образом операцию (other-operation);
4) просто маркируют декорируемый объект.

Применять декораторы важно осмысленно и с учётом их порядка и способа влияния на поведение:

```python
@post_operation_n
@post_operation_2
...
@post_operation_1
@pre_operation_1
@pre_operation_2
...
@pre_operation_n
@other_operation
def some_basic_function(...):
    ...
```

Большое количество декораторов затрудняет понимание кода и ухудшает его ясность.
Старайтесь за редкими случаями не применять к функции больше одного декоратора.


*TODO: WebAPIs, release & deploy, message bus, microservices*
